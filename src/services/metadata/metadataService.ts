// import { EncryptionDataType, KeyPairType_Mint } from '@dapp/types/typesDapp/metadata/encryption';
import { 
  BoxInfoFormType,
} from '@Create/types/stateType';
import { AllStepOutputs } from '@Create/types/stepType';
import {
  initialMetadataBox,
  MetadataBoxType,
  MintMethodType,
} from '@dapp/types/typesDapp/metadata/metadataBox'; 
import {
  initialMetadataNFT,
  MetadataNFTType,
} from '@dapp/types/typesDapp/metadata/metadataNFT'; 

import {
  initialResultData,
  ResultDataType,
} from '@dapp/types/typesDapp/metadata/resultData';
import { CIDIsExitingType } from '@dapp/types/typesDapp/otherTypes';


export const metadataService = {

  createMetadataBox: async (
    boxInfoForm: BoxInfoFormType,
    allStepOutputs: AllStepOutputs,
    // encryptionData: EncryptionDataType,
    // keyPair: KeyPairType_Mint,
  ) : Promise<MetadataBoxType> => {
    try {
      // Verify required data
      if(allStepOutputs.nft_image_cid === '' ) {
        throw new Error('image is empty!');
      }
      if (allStepOutputs.box_image_cid === '') {
        throw new Error('image2 is empty!');
      }
      if(allStepOutputs.file_cid_list.length === 0) {
        throw new Error('file is empty!');
      }
      // 
      let public_key_let = '';
      let file_list_let: string[] = [];
      let encryption_slices_metadata_cid_let = {
        encryption_data: '',
        encryption_iv: '',
      };
      // Verify encryption data
      if(boxInfoForm.mint_method === 'createAndPublish') {
        
        file_list_let = allStepOutputs.file_cid_list;
      } else if(boxInfoForm.mint_method === 'create') {
        if(allStepOutputs.key_pair.public_key_minter === '') {
          throw new Error('public_key_minter is empty!');
        }
        public_key_let = allStepOutputs.key_pair.public_key_minter;
        // Verify file chunk count
        if (
          allStepOutputs.encryption_slices_metadata_cid.encryption_data === '' ||
          allStepOutputs.encryption_slices_metadata_cid.encryption_iv === ''
        ) {
          throw new Error('slices_metadata_cid_encryption is empty!');
        }
        encryption_slices_metadata_cid_let = allStepOutputs.encryption_slices_metadata_cid;

        // Verify encryption data for each chunk
        for (let i = 0; i < allStepOutputs.encryption_file_cid.length; i++) {
          if (
            allStepOutputs.encryption_file_cid[i].encryption_iv === '' || 
            allStepOutputs.encryption_file_cid[i].encryption_data === ''
          ) {
            throw new Error('encryption_file_cid is empty!');
          }
        }

        // Verify password encryption data
        if(
          allStepOutputs.encryption_passwords.encryption_iv === '' ||
          allStepOutputs.encryption_passwords.encryption_data === ''
        ) {
          throw new Error('encryptionData is empty!');
        } 
      } else {
        throw new Error('mintMethod is invalid!');
      }

      // Create MetadataBox object
      const metadataBox: MetadataBoxType = {
        ...initialMetadataBox,
        // BoxInfo Data
        type_of_crime: boxInfoForm.type_of_crime,
        label: boxInfoForm.label || [], // Added label property
        title: boxInfoForm.title,
        country: boxInfoForm.country,
        state: boxInfoForm.state,
        description: boxInfoForm.description,
        event_date: boxInfoForm.event_date,
        create_date: allStepOutputs.current_time.create_date,
        timestamp: Number(allStepOutputs.current_time.timestamp), // Convert to number
        // Image Data
        nft_image: `ipfs://${allStepOutputs.nft_image_cid}`,
        box_image: `ipfs://${allStepOutputs.box_image_cid}`,
        // Mint Method
        mint_method: boxInfoForm.mint_method,
        // Encryption Data
        encryption_slices_metadata_cid: encryption_slices_metadata_cid_let,
        encryption_file_cid: allStepOutputs.encryption_file_cid,
        encryption_passwords: allStepOutputs.encryption_passwords,
        public_key: public_key_let,
        // File Data
        file_list: file_list_let,
        // password: '',
      };

      return metadataBox;
    } catch (error) {
      console.error('Create MetadataBox failed:', error);
      throw error;
    }
  },

  createMetadataNFT: async (
    boxInfoForm: BoxInfoFormType,
    allStepOutputs: AllStepOutputs,
  ) : Promise<MetadataNFTType> => {
    try {
      // Verify required data
      if(allStepOutputs.nft_image_cid === '' ) {
        throw new Error('image is empty!');
      }

      // Create MetadataNFT object
      const metadataNFT: MetadataNFTType = {
        ...initialMetadataNFT,
        // Basic Info
        token_id: '', // tokenId generated by contract after mint
        type_of_crime: boxInfoForm.type_of_crime,
        title: boxInfoForm.title,
        country: boxInfoForm.country,
        state: boxInfoForm.state,
        // Image
        image: `ipfs://${allStepOutputs.nft_image_cid}`,
        event_date: boxInfoForm.event_date,
        // Attributes
        // attributes: [
        //   ...initialMetadataNFT.attributes,
        // ]
      };

      return metadataNFT;
    } catch (error) {
      console.error('Create MetadataNFT failed:', error);
      throw error;
    }
  },

  createResultData: (
    mint_method: MintMethodType,
    file_cid_list: string[],
    cid_list: CIDIsExitingType[],
    is_success: boolean,
    timestamp: string,
  ) => {
    try {
      if (!timestamp) {
        throw (' timestamp is empty!');
      }
      if (file_cid_list.length === 0) {
        throw (' file_cid_list is empty!');
      }
      if (cid_list.length === 0) {
        throw (' cid_list is empty!');
      }

      const resultData: ResultDataType = {
        ...initialResultData,
        mint_method: mint_method,
        file_cid_list: file_cid_list,
        timestamp: timestamp,
        is_success: is_success,
        cid_list: cid_list.map(cid => cid.cid),
      };
      return resultData;
    } catch (error) {
      console.error('Create Result data JSON failed:', error);
      throw error;
    }
  }


}; 